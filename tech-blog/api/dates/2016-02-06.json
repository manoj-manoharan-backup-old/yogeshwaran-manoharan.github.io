[{"title":"Floating Point Demystified, Part 2: Why Doesn't 0.1 + 0.2 == 0.3?","description":"<p>This is the second article in a series.  My previous entry\n<a href=\"/2014/09/what-every-computer-programmer-should.html\">Floating Point Demystified, Part 1</a>\nwas pretty dense with background information.  For part 2\nlet’s answer a burning, practical question that bites almost\nevery new programmer at some point:</p>\n\n<p>Why oh why doesn’t <code class=\"language-plaintext highlighter-rouge\">0.1 + 0.2 == 0.3</code>?</p>\n\n<p>The answer is: it does!  In mathematics.  But floating point has\nfailed at this before we even get to the addition part.\nDouble-precision floating point is totally incapable of representing\n<code class=\"language-plaintext highlighter-rouge\">0.1</code>, <code class=\"language-plaintext highlighter-rouge\">0.2</code>, <em>or</em> <code class=\"language-plaintext highlighter-rouge\">0.3</code>.  When you <em>think</em> you’re adding those\nnumbers in double-precision, here is what you are actually adding</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"hi","link":"https://blog.reverberate.org/2016/02/06/floating-point-demystified-part2.html","owner":"Josh Haberman"},{"title":"Self Adjusting DOM","description":"<p>I’ve been <a href=\"/incrementality-and-the-web/\">thinking recently</a> about how to\nstructure dynamic web applications, and in particular about the role that\nincremental computation should play.</p>\n\n","link":"https://blog.janestreet.com/self-adjusting-dom/","owner":"Jane Street"}]