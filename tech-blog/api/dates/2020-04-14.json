[{"title":".NET Core performance revolution in Rider 2020.1","description":"<p><em>This blog post was <a href=\"https://blog.jetbrains.com/dotnet/2020/04/14/net-core-performance-revolution-rider-2020-1/\">originally posted</a> on <a href=\"https://blog.jetbrains.com/dotnet/\">JetBrains .NET blog</a>.</em></p>\n<p>Many <a href=\"https://www.jetbrains.com/rider/\">Rider</a> users may know that <a href=\"https://www.codemag.com/Article/1811091/Building-a-.NET-IDE-with-JetBrains-Rider\">the IDE has two main processes</a>: frontend (Java-application based on the IntelliJ platform) and backend (.NET-application based on ReSharper). Since the first release of Rider, we’ve used Mono as the backend runtime on Linux and macOS. A few years ago, we decided to migrate to .NET Core. After resolving hundreds of technical challenges, <strong>we are finally ready to present the .NET Core edition of Rider!</strong></p>\n<p>In this blog post, we want to share the results of some benchmarks that compare the Mono-powered and the .NET Core-powered editions of Rider. You may find this interes","link":"https://aakinshin.net/posts/netcore-performance-revolution-in-rider-2020-1/","owner":"Andrey Akinshin"},{"title":"Effective Software Design Documents","description":"<h2 id=\"introduction\">Introduction</h2>\n\n<p>At WePay, we have a well defined process and structure to document software design. This post describes our design process and <a href=\"https://github.com/wepay/design_doc_template\">software design template</a>.</p>\n\n<h2 id=\"background\">Background</h2>\n\n<p>Every early stage software company has one goal: to ship software ASAP. This attitude is essential for the business to survive. But it promotes the idea that “<em>Code is the documentation</em>”. This gets out of hand quickly.</p>\n\n<p>WePay started off developing software using a <a href=\"https://en.wikipedia.org/wiki/LAMP_(software_bundle)\">LAMP</a> stack. In the beginning, the code was not complicated. As the company rolled out new features and grew the team, the lack of documentation slowed developer productivity.</p>\n\n<p><img src=\"/assets/2020-04-14-effective-software-design-documents/graph.png\" alt=\"img\" /></p>\n\n<p>Teams were not communicating well, either. For example, we evaluated th","link":"https://wecode.wepay.com/posts/effective-software-design-documents","owner":"WePay"},{"title":"Improving Application Performance with Duplicate Indexes","description":"When you&#x2019;re distributing a SQL database geographically, it can be tough to get fast application performance. Data often has to make long, round trip journeys across the world and is restricted by a speed limit (the speed of light).&#xA0;\nSo what can you do to ensure you&#x2019;re getting the best performance possible for your use case? Utilizing a &#x201C;duplicate indexes&#x201D; topology pattern is a great place to start.","link":"https://www.cockroachlabs.com/blog/improving-application-performance-with-duplicate-indexes/","owner":"CockroachDB"},{"title":"More fun with NumPy, CuPy, Clojure and GPU acceleration. Hold my Cider 2!","description":"<p>\nNumPy and CuPy converted my computations to <code>float64</code> despite being told to\nwork with <code>float32</code>, and that prompted some readers to discard my <a href=\"./Clojure-Numpy-Cupy-CPU-GPU\">previous article</a>\nas <i>faulty</i>. My article doesn't make CuPy and NumPy more or less perfect, though,\nand that forceful conversion stings everyone who is using Nvidia's\nGTX gaming GPUs. I don't have grants that would cover $10,000 for uncrippled\n<code>float64</code> support on Tesla GPU. So, if you're poor like me, that article\nprobably offered valuable information.\n</p>\n\n<p>\nI've received some nice suggestions, too. Some readers were inspired by my article\nand re-implemented that <code>corrcoef</code> function in their favorite Python tools\n(Numpy, CuPy, PyTorch) and found out that the advice from my book <a href=\"https://aiprobook.com/numerical-linear-algebra-for-programmers\">Numerical Linear Algebra for Programmers</a>\nis not constrained to Clojure, and that it is fast in N","link":"http://dragan.rocks/articles/20/Clojure-Numpy-Cupy-CPU-GPU-2","owner":"Dragan Djuric"},{"title":"MVP is DEAD! Long live MVP!","description":"In this article I am going to describe a modern approach to using the MVP pattern in an Android application. If you are familiar with MVP then still there might be some things here that might be useful. A long time ago in a galaxy far away… We used the MVP pattern and it was...","link":"https://tech.justeattakeaway.com/2020/04/14/mvp-is-dead-long-live-mvp/","owner":"Just Eat"},{"title":"TPDP Episode #35: Developing on the Blockchain","description":"\n                    <p>I&rsquo;m pleased to announce that the latest episode of The Polyglot Developer Podcast has been published to <a href=\"https://itunes.apple.com/us/podcast/the-polyglot-developer-podcast/id1070975158\">Apple Podcasts</a>, <a href=\"https://open.spotify.com/show/5eUHubRedHe3ljcnMsyG2T?si=h7873UMlRCiy_HRdeqG3bg\">Spotify</a>, and pretty much every other major podcasting networking that exists.</p>\n<p>The topic of this episode, <strong>Developing on the Blockchain</strong>, is the blockchain, and I&rsquo;m joined by expert <a href=\"https://www.linkedin.com/in/lennartfrantzell/\">Lennart Frantzell</a> from IBM to help walk us through everything you should know when it comes to developing on it.</p>\n<p>If you&rsquo;re interested in cryptocurrency, this episode is not for you. Instead, we&rsquo;re exploring what the blockchain is, why people are developing on it, and how you can start developing your next application on it as well.</p>\n                    \n                ","link":"https://www.thepolyglotdeveloper.com/2020/04/tpdp-e35-developing-on-the-blockchain/","owner":"Nic Raboy"}]