[{"title":"Going async — a case study","description":"","link":"https://tech.xing.com/going-async-a-case-study-b28ec0bf92e8?source=rss----35cb8c78d3cf---4","owner":"XING"},{"title":"Introducing Pebble: A RocksDB Inspired Key-Value Store Written in Go","description":"Since its inception, CockroachDB has relied on RocksDBas its key-value storage engine. The choice of RocksDB has served us well. RocksDB is battle tested, highly performant, and comes with a rich feature set. We&#x2019;re big fans of RocksDB and we frequently sing its praises when asked why we didn&#x2019;t choose another storage engine.\nToday we&#x2019;re introducing Pebble: a RocksDB inspired and RocksDB compatible key-value store focused on the needs of CockroachDB.","link":"https://www.cockroachlabs.com/blog/pebble-rocksdb-kv-store/","owner":"CockroachDB"},{"title":"Memory allocator showdown","description":"Since version 4.10, OCaml offers a new best-fit memory allocator\nalongside its existing default, the next-fit allocator. At Jane\nStreet, we've seen a big improvement after switching over to the new\nallocator.\n\nThis post isn't about how the new allocator works. For that, the best\nsource is these notes from a talk by its\nauthor.  Instead, this post is about just how tricky it is to compare two\nallocators in a reasonable way, especially for a garbage-collected\nsystem.\n  \n","link":"https://blog.janestreet.com/memory-allocator-showdown/","owner":"Jane Street"},{"title":"Optimising Webpack Build Performance","description":"It was time for a tune-up of our webpack configuration. We took some time \r\nto try out different options and see how they impacted our build \r\nperformance in order to drive our build times down.","link":"https://devblog.kogan.com/blog/optimising-webpack-build-performance","owner":"Kogan.com"},{"title":"Python and Go : Part IV - Using Python in Memory","description":"Series Index Python and Go: Part I - gRPC\nPython and Go: Part II - Extending Python With Go\nPython and Go: Part III - Packaging Python Code\nPython and Go: Part IV - Using Python in Memory\nIntroduction In a previous post we used gRPC to call Python code from Go. gRPC is a great framework, but there is a performance cost to it. Every function call needs to marshal the arguments using protobuf, make a network call over HTTP/2, and then un-marshal the result using protobuf.","link":"https://www.ardanlabs.com/blog/2020/09/using-python-memory.html","owner":"William Kennedy"},{"title":"Tackling the Awkward Squad for Reactive Programming","description":"<p ><a href=\"https://2020.ecoop.org/details/ecoop-2020-papers/19/Tackling-the-Awkward-Squad-for-Reactive-Programming-The-Actor-Reactor-Model\">https://2020.ecoop.org/details/ecoop-2020-papers/19/Tackling-the-Awkward-Squad-for-Reactive-Programming-The-Actor-Reactor-Model</a></p>\n<p >\nSam Van den Vonder, Thierry Renaux, Bjarno Oeyen, Joeri De Koster, Wolfgang De Meuter\n</p>\n<p >\nReactive programming is a programming paradigm whereby programs are internally represented by a dependency graph, which is used to automatically (re)compute parts of a program whenever its input changes. In practice reactive programming can only be used for some parts of an application: a reactive program is usually embedded in an application that is still written in ordinary imperative languages such as JavaScript or Scala. In this paper we investigate this embedding and we distill “the awkward squad for reactive programming” as 3 concerns that are essential for real-world software development, but that do not fi","link":"http://lambda-the-ultimate.org/node/5603","owner":"Lambda the Ultimate"},{"title":"Taking Another Look at Phoenix and Elixir - Part 1 - Upgrading","description":"<p class=\"center\"><img src=\"/blog/assets/IMG_3241.jpeg\" alt=\"IMG_3241.jpeg\" /></p>\n\n<p>I've been on the fence about Phoenix and Elixir for a while and I thought I'd take at least a quick dive.  I've had a development system for Phoenix and Elixir since at least 2016 but I haven't done much.  This means that the first task is bringing it into the 2020s.</p>\n\n<h2 id=\"upgrading-elixir\">Upgrading Elixir</h2>\n\n<p>I installed Elixir via HomeBrew which means it is a simple:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>which elixir\n/usr/local/bin/elixir\n</code></pre></div></div>\n\n<p><strong>Note</strong>: It can be hard sometimes to know if you installed things via HomeBrew and checking their location is an easy cheap as HomeBrew installs stuff to /usr/local/bin</p>\n\n<p>And then:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>brew upgrade elixir\n</code></pre></div></div>\n\n<","link":"http://fuzzyblog.io/blog/elixir/2020/09/15/taking-another-look-at-phoenix-and-elixir-part-1-upgrading.html","owner":"Scott Johnson"}]