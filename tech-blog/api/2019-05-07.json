[{"title":"Management Command Aliases","description":"Django Management Commands\r\n\r\nA quick minor efficiency tip for today that'll make your life at the Django \r\ncommand line incrementally better.\r\n\r\nYou're using django-extensions in your project, right? If not, go and \r\nrectify that problem immediately.\r\n\r\nThe best featureâ„¢ that django-extensions provides is the shell_plus \r\ncommand. You know the worst thing about `shell_plus`? The name. That's a \r\nlong name to type out into your shell, especially since it's snake_case, \r\nand I type the command approximately 15,000 times per day. Wouldn't it be \r\nnice to alias `shell_plus` to something like `sh`? Well, now you can!","link":"https://devblog.kogan.com/blog/management-command-aliases","owner":"Kinvolk"},{"title":"My Take on Property-Based Testing","description":"","link":"https://medium.com/erlang-battleground/property-based-testing-erlang-elixir-de72ad24966b?source=rss-788b9596f013------2","owner":"Brendan Gregg"},{"title":"Reader/Reader blocking in reader/writer locks","description":"tl;dr In writer-priority reader/writer locks, as soon as a single writer enters the acquisition queue, all future accesses block behind any in-flight reads. If any readers hold the lock for extended periods of time, this can lead to extreme pauses and loss of throughput given even a very small number of writers.\nAbstract This post describes a phenomenon that can occur in systems built on reader/writer locks, where slow readers and a small number of writers (e.","link":"https://blog.nelhage.com/post/rwlock-contention/","owner":"Natasha Murashev"}]