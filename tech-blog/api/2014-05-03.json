[{"title":"Methods, Interfaces and Embedded Types in Go","description":"Introduction\nMy business partner Ed asked me what would happen if a struct and an embedded field both implemented the same interface. We asked ourselves two questions:\nWould the compiler throw an error because we now had two implementations of the interface? If the compiler accepted the type declaration, how does the compiler determine which implementation to use for interface calls? We hacked out some code to answer the questions and then I dug into the specification.","link":"https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html","owner":"Wilfred Hughes"},{"title":"Object Pooling For Efficiency","description":"\n                    <p>When it comes to computing, not all devices are created equal. An action intense game that runs at 500 frames per second on a computer may only run at 12 frames per second on a mobile device. To maximize your frame rate across all platforms it is very important to use your game resources efficiently.</p>\n<p>One of the best things you can do for your game is to use object pooling. This conserves resources by recycling a pre-defined set of objects rather than dynamically creating and destroying them as necessary.</p>\n                    \n                        <p>The post <a rel='nofollow' href='https://www.thepolyglotdeveloper.com/2014/05/object-pooling-for-efficiency/'>Object Pooling For Efficiency</a> appeared first on <a rel='nofollow' href='https://www.thepolyglotdeveloper.com'>The Polyglot Developer</a>.</p>\n                    \n                ","link":"https://www.thepolyglotdeveloper.com/2014/05/object-pooling-for-efficiency/","owner":"Nelson Elhage"}]