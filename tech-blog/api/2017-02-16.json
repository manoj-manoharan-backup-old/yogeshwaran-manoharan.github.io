[{"title":"Jane Street Tech Talks: Verifying Puppet Configs","description":"<p>Our first <a href=\"/how-to-build-an-exchange/\">Jane Street Tech Talk</a> went really well!\nThanks to everyone who came and made it a fun event.</p>\n\n","link":"https://blog.janestreet.com/jane-street-tech-talks-verifying-puppet-configs/","owner":"InVision"},{"title":"Who Owns Who?","description":"<p>Designing an API with creation and destruction of objects can be tricky,\nparticularly if the objects have dependency relationships. </p>\n<p>How do we ensure that constructed API objects get destroyed at the appropriate time (and are not 'leaked')?\nHow do we prevent code from attempting to access objects after destruction?\nAnd how do we do all this in situations where some objects depend on the existence of other objects? </p>\n<p>In this post I talk about how I approached this in <a href=\"http://pathengine.com\">PathEngine</a>\n(a pathfinding library, in C++).</p>\n<p>When I first designed the PathEngine API, I chose an approach based on larger objects each owning a set of smaller 'contained' objects.\nThat kind of worked out, but it turns out there's another, much better way to do this.\nAnd so it was that I recently found myself going through the SDK and <em>turning the whole thing upside down</em>.</p><h2 id=\"objects-on-a-ground-mesh\">Objects on a ground mesh</h2>\n<p>The ownership issu","link":"https://upcoder.com/17/who-owns-who","owner":"The Daily WTF"}]